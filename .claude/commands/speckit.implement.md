---
description: tasks.md에 정의된 모든 태스크를 처리하여 구현 계획을 실행합니다
---

## 사용자 입력

```text
$ARGUMENTS
```

사용자 입력이 비어있지 않으면 **반드시** 고려한 후 진행하세요.

## 실행 절차

1. 저장소 루트에서 `.specify/scripts/bash/check-prerequisites.sh --json --require-tasks --include-tasks`를 실행하고 FEATURE_DIR과 AVAILABLE_DOCS 목록을 파싱합니다. 모든 경로는 절대 경로여야 합니다. 인자에 작은따옴표가 포함된 경우(예: "I'm Groot") 이스케이프 구문을 사용하세요: 예) 'I'\''m Groot' (또는 가능하면 큰따옴표 사용: "I'm Groot").

2. **체크리스트 상태 확인** (FEATURE_DIR/checklists/ 디렉토리가 존재하는 경우):
   - checklists/ 디렉토리의 모든 체크리스트 파일을 스캔합니다
   - 각 체크리스트에 대해 집계합니다:
     - 전체 항목: `- [ ]` 또는 `- [X]` 또는 `- [x]`와 일치하는 모든 줄
     - 완료 항목: `- [X]` 또는 `- [x]`와 일치하는 줄
     - 미완료 항목: `- [ ]`와 일치하는 줄
   - 상태 테이블을 생성합니다:

     ```text
     | 체크리스트 | 전체 | 완료 | 미완료 | 상태 |
     |-----------|------|------|--------|------|
     | ux.md     | 12   | 12   | 0      | ✓ 통과 |
     | test.md   | 8    | 5    | 3      | ✗ 실패 |
     | security.md | 6  | 6    | 0      | ✓ 통과 |
     ```

   - 전체 상태를 계산합니다:
     - **통과**: 모든 체크리스트의 미완료 항목이 0개
     - **실패**: 하나 이상의 체크리스트에 미완료 항목이 있음

   - **미완료 체크리스트가 있는 경우**:
     - 미완료 항목 수가 포함된 테이블을 표시합니다
     - **중단**하고 질문합니다: "일부 체크리스트가 미완료 상태입니다. 그래도 구현을 진행하시겠습니까? (예/아니오)"
     - 사용자 응답을 기다린 후 계속합니다
     - 사용자가 "아니오", "대기", "중단"이라고 하면 실행을 중지합니다
     - 사용자가 "예", "진행", "계속"이라고 하면 3단계로 진행합니다

   - **모든 체크리스트가 완료된 경우**:
     - 모든 체크리스트가 통과했음을 보여주는 테이블을 표시합니다
     - 자동으로 3단계로 진행합니다

3. 구현 컨텍스트를 로드하고 분석합니다:
   - **필수**: tasks.md에서 전체 태스크 목록과 실행 계획을 읽습니다
   - **필수**: plan.md에서 기술 스택, 아키텍처, 파일 구조를 읽습니다
   - **존재 시**: data-model.md에서 엔티티와 관계를 읽습니다
   - **존재 시**: contracts/에서 API 명세와 테스트 요구사항을 읽습니다
   - **존재 시**: research.md에서 기술 결정사항과 제약사항을 읽습니다
   - **존재 시**: quickstart.md에서 통합 시나리오를 읽습니다

4. **프로젝트 설정 검증**:
   - **필수**: 실제 프로젝트 설정에 기반하여 ignore 파일을 생성/검증합니다:

   **감지 및 생성 로직**:
   - 다음 명령이 성공하는지 확인하여 git 저장소인지 판별합니다 (맞으면 .gitignore 생성/검증):

     ```sh
     git rev-parse --git-dir 2>/dev/null
     ```

   - Dockerfile*이 존재하거나 plan.md에 Docker가 있으면 → .dockerignore 생성/검증
   - .eslintrc*가 존재하면 → .eslintignore 생성/검증
   - eslint.config.*가 존재하면 → 설정의 `ignores` 항목이 필요한 패턴을 포함하는지 확인
   - .prettierrc*가 존재하면 → .prettierignore 생성/검증
   - .npmrc 또는 package.json이 존재하면 → .npmignore 생성/검증 (퍼블리싱 시)
   - terraform 파일(*.tf)이 존재하면 → .terraformignore 생성/검증
   - helm 차트가 있어 .helmignore가 필요하면 → .helmignore 생성/검증

   **ignore 파일이 이미 존재하는 경우**: 필수 패턴이 포함되어 있는지 확인하고, 누락된 중요 패턴만 추가합니다
   **ignore 파일이 없는 경우**: 감지된 기술에 맞는 전체 패턴 세트로 생성합니다

   **기술별 공통 패턴** (plan.md 기술 스택 기준):
   - **Node.js/JavaScript/TypeScript**: `node_modules/`, `dist/`, `build/`, `*.log`, `.env*`
   - **Python**: `__pycache__/`, `*.pyc`, `.venv/`, `venv/`, `dist/`, `*.egg-info/`
   - **Java**: `target/`, `*.class`, `*.jar`, `.gradle/`, `build/`
   - **C#/.NET**: `bin/`, `obj/`, `*.user`, `*.suo`, `packages/`
   - **Go**: `*.exe`, `*.test`, `vendor/`, `*.out`
   - **Ruby**: `.bundle/`, `log/`, `tmp/`, `*.gem`, `vendor/bundle/`
   - **PHP**: `vendor/`, `*.log`, `*.cache`, `*.env`
   - **Rust**: `target/`, `debug/`, `release/`, `*.rs.bk`, `*.rlib`, `*.prof*`, `.idea/`, `*.log`, `.env*`
   - **Kotlin**: `build/`, `out/`, `.gradle/`, `.idea/`, `*.class`, `*.jar`, `*.iml`, `*.log`, `.env*`
   - **C++**: `build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.so`, `*.a`, `*.exe`, `*.dll`, `.idea/`, `*.log`, `.env*`
   - **C**: `build/`, `bin/`, `obj/`, `out/`, `*.o`, `*.a`, `*.so`, `*.exe`, `Makefile`, `config.log`, `.idea/`, `*.log`, `.env*`
   - **Swift**: `.build/`, `DerivedData/`, `*.swiftpm/`, `Packages/`
   - **R**: `.Rproj.user/`, `.Rhistory`, `.RData`, `.Ruserdata`, `*.Rproj`, `packrat/`, `renv/`
   - **공통**: `.DS_Store`, `Thumbs.db`, `*.tmp`, `*.swp`, `.vscode/`, `.idea/`

   **도구별 패턴**:
   - **Docker**: `node_modules/`, `.git/`, `Dockerfile*`, `.dockerignore`, `*.log*`, `.env*`, `coverage/`
   - **ESLint**: `node_modules/`, `dist/`, `build/`, `coverage/`, `*.min.js`
   - **Prettier**: `node_modules/`, `dist/`, `build/`, `coverage/`, `package-lock.json`, `yarn.lock`, `pnpm-lock.yaml`
   - **Terraform**: `.terraform/`, `*.tfstate*`, `*.tfvars`, `.terraform.lock.hcl`
   - **Kubernetes/k8s**: `*.secret.yaml`, `secrets/`, `.kube/`, `kubeconfig*`, `*.key`, `*.crt`

5. tasks.md 구조를 파싱하여 추출합니다:
   - **태스크 단계**: 설정, 테스트, 핵심, 통합, 마무리
   - **태스크 의존성**: 순차 vs 병렬 실행 규칙
   - **태스크 상세**: ID, 설명, 파일 경로, 병렬 마커 [P]
   - **실행 흐름**: 순서 및 의존성 요구사항

6. 태스크 계획에 따라 구현을 실행합니다:
   - **단계별 실행**: 각 단계를 완료한 후 다음 단계로 이동합니다
   - **의존성 준수**: 순차 태스크는 순서대로, 병렬 태스크 [P]는 동시 실행 가능합니다
   - **TDD 접근법**: 테스트 태스크를 해당 구현 태스크보다 먼저 실행합니다
   - **파일 기반 조율**: 같은 파일에 영향을 주는 태스크는 순차적으로 실행해야 합니다
   - **검증 체크포인트**: 다음 단계 진행 전 각 단계 완료를 확인합니다

7. 구현 실행 규칙:
   - **설정 우선**: 프로젝트 구조, 의존성, 설정을 초기화합니다
   - **코드 전 테스트**: 계약, 엔티티, 통합 시나리오에 대한 테스트를 작성해야 하는 경우 먼저 작성합니다
   - **핵심 개발**: 모델, 서비스, CLI 명령, 엔드포인트를 구현합니다
   - **통합 작업**: 데이터베이스 연결, 미들웨어, 로깅, 외부 서비스를 연결합니다
   - **마무리 및 검증**: 단위 테스트, 성능 최적화, 문서화를 수행합니다

8. 진행 상황 추적 및 에러 처리:
   - 각 태스크 완료 후 진행 상황을 보고합니다
   - 비병렬 태스크가 실패하면 실행을 중단합니다
   - 병렬 태스크 [P]의 경우, 성공한 태스크는 계속 진행하고 실패한 태스크를 보고합니다
   - 디버깅을 위한 컨텍스트와 함께 명확한 에러 메시지를 제공합니다
   - 구현을 계속할 수 없는 경우 다음 단계를 제안합니다
   - **중요**: 완료된 태스크는 tasks 파일에서 반드시 [X]로 체크합니다

9. 완료 검증:
   - 모든 필수 태스크가 완료되었는지 확인합니다
   - 구현된 기능이 원래 사양과 일치하는지 확인합니다
   - 테스트 통과 및 커버리지 요구사항 충족 여부를 검증합니다
   - 구현이 기술 계획을 따르는지 확인합니다
   - 완료된 작업 요약과 함께 최종 상태를 보고합니다

10. **루트 spec.md 동기화**:

    모든 태스크가 완료되고 검증된 후, 프로젝트 루트의 명세 문서(`spec.md`)에
    새로 구현된 기능을 반영합니다.

    **전제 조건**: 루트 `spec.md`가 이미 존재해야 합니다. 존재하지 않으면
    이 단계를 건너뛰고 "루트 spec.md 파일이 없어 업데이트를 건너뜁니다"라고
    사용자에게 알립니다.

    **처리 절차**:
    1. 루트 `spec.md`를 읽어 현재 구조, 제목 계층, 문서 스타일(언어, 포맷팅
       규칙, 표 형식)을 파악합니다.
    2. `FEATURE_DIR`에서 기능의 `spec.md`와 `plan.md`를 읽어 다음 항목을
       추출합니다:
       - 신규/변경된 API 엔드포인트
       - 신규/변경된 데이터 모델 및 스키마 필드
       - 신규/변경된 프론트엔드 페이지, 컴포넌트, 라우트
       - 신규/변경된 설정 또는 환경 변수
       - 신규/변경된 외부 API 연동
       - 추가된 테스트 커버리지
       - 알려진 제한사항 또는 TODO 항목
    3. 업데이트 유형을 결정합니다:
       - **신규 섹션**: 기존 섹션에서 다루지 않는 완전히 새로운 기능
         → 기존 스타일에 맞춰 새 섹션을 추가합니다.
       - **섹션 업데이트**: 기존 기능을 확장하거나 수정하는 경우
         → 해당 섹션을 직접 수정합니다 (표에 행 추가, 하위 섹션 추가,
         설명 업데이트 등).
       - **횡단 변경**: 여러 기존 섹션에 걸쳐 영향을 미치는 경우
         → 영향받는 각 섹션을 개별적으로 업데이트합니다.
    4. 루트 `spec.md`에 변경사항을 적용합니다:
       - 기존 문서의 언어를 **반드시** 맞춰야 합니다 (예: 루트 spec이
         한국어로 작성되어 있으면 한국어로 업데이트).
       - 기존 제목 계층과 표 형식을 **반드시** 그대로 유지해야 합니다.
       - 기능이 기존 동작을 명시적으로 대체하는 경우를 제외하고
         기존 내용을 **절대** 삭제하거나 재작성하지 않습니다.
       - "최종 업데이트" 또는 "Last Updated" 날짜가 있으면
         오늘 날짜로 **반드시** 갱신합니다.
       - "미구현/제한사항" 섹션이 있으면, 이번 구현으로 해결된 항목은
         제거하고 구현 중 발견된 새 제한사항이 있으면 추가합니다.
    5. 루트 `spec.md` 변경 요약을 표시합니다:

       ```text
       ## 루트 spec.md 동기화 요약
       - 업데이트된 섹션: [목록]
       - 추가된 섹션: [목록]
       - 해결된 제한사항: [목록]
       - 추가된 제한사항: [목록]
       ```

    6. 기능이 너무 복잡하여 자동 병합이 어려운 경우(예: 대규모 구조 재편이
       필요한 경우), **무리하게 적용하지 않습니다**. 대신 사용자에게 안내합니다:
       "루트 spec.md에 이 기능을 반영하려면 수동 구조 재편이 필요합니다.
       통합할 새 콘텐츠 초안을 아래에 제공합니다: [초안]"

참고: 이 명령은 tasks.md에 완전한 태스크 분해가 존재한다고 가정합니다. 태스크가 불완전하거나 누락된 경우, `/speckit.tasks`를 먼저 실행하여 태스크 목록을 재생성하세요.
